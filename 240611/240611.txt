기본 자료형의 형변환 (Type Casting) 
정수 : byte(1) < short(2) < int (4) < long(8)

조건) 

- 암묵적형변환 = 자동형변환 = 업캐스팅
숫자 자료형의 경우 : 용량이 작은 값을 용량이 큰 값을 가질 수 있는 변수에 넣을 수 있다.
ex)
byte b = 50;
int i = b; // 업캐스팅
double d = i; // 업캐스팅
System.out.println(i); ==> 50 출력 : 형변환이 진행되더라도 초기의 자료형은 변환되지 않는다.
System.out.println(d); ==> 50.0 출력 : 변수가 값 자리에 위치했을 때만 임시적으로 자료형이 바뀐다.

long l = 50L; or long l = 50l; : long의 경우에는 long 자료형이라는 것을 알려주기 위해 L,l 중에 하나를 붙여준다.
long l = il (X) / long l = i (O) : 값 자리에 변수명이 들어오는 경우에는 L을 붙여주면 새로운 변수명으로 이해하기 때문에 붙여주지 않는다.

float f = 5.0F; or float f = 5.0f; 

long l = 50l; //(8B)
float f = l; //(4B) -> 값 손실이 일어날 수 있다. 
=> long이 용량은 더 크지만 실수의 숫자 표현범위가 더 넓기 때문에 가능하다.

- 명시적형변환 = 강제형변환 = 다운캐스팅 : 값 손실이 일어난다.
나의 자료형보다 작은 자료형으로 변환하는 경우 
조건 ) 반드시 변환하고자 하는(값을 받는 곳의) 자료형으로 캐스트연산자를 사용하여 변환해주어야 한다.
캐스트 연산자 : (변환하고자하는 자료형)변수명; 형태로 사용
ex) 
int i = 50;
byte b = i; (X) : 큰 공간에서 작은 공간의 자료형으로 형 변환 불가능
byte b = (byte)i; (O)

--
전위연산자 : ++a, --a -> 먼저 a에 1을 더한다. 
ex) int a; System.out.println(++a); -> 결과값 : 6, 변수 a = 6  -> 출력하기 전에 a에 +1을 하기 때문에 결과값, 변수 모두 6
후위연산자 : a++, a-- -> 가장 마지막에 a에 1을 더한다.
ex) int a; System.out.println(a++); -> 결과값 : 5, 변수 a = 6 -> 출력한 이후에 a에 +1을 하기 때문에 결과값은 5, 변수는 6

혼합대입연산자
ex) a += 5; -> a = a + 5;
a -= 5; -> a = a - 5;
a *=5; -> a = a * 5;
a /= 5; -> a = a / 5;
a %= 5; -> a = a % 5; ===> 결과값이 몫이 아닌 나머지를 가진다는 것 주의!
* a의 위치에 따라 계산 결과값이 달라질 수 있기 때문에 위치에 주의할 것.

String a = "하하";
a += "호호"; => a = a + "호호"; -> a = "하하" + "호호";

비교연산자 : 참 혹은 거짓의 결과만 반환
ex) 1 < 5 : 참 (true)
1 > 5 : 거짓(false)

1 = 1일 경우, 컴퓨터는 '1을 1에 대입하세요'라고 인식하기 때문에 우리가 아는 '같다'의 의미를 사용할 때는 '==' 사용
ex)
1 == 1 : 참(true)
1 != 1 : 거짓(false)

논리연산자
논리곱
- && : ~이고(AND) : 모든 항이 true인 경우만 true, 그렇지 않으면 false 반환 -> 첫번째 항이 false라면 어차피 false 값이 반환되기 때문에 뒤에 있는 항의 연산이 진행되지 않는다.
ex) true && true : true
true && false : false
false && true : false
false && false : false
논리합
- || : ~이거나(OR) : 모든 항이 false인 경우만 false, 그렇지 않으면 true 반환 -> 첫번째 항이 true라면 어차피 true 값이 반환되기 때문에 뒤에 있는 항의 연산이 진행되지 않는다.
ex) true || true : true
true || false : true
false || true : true
false || false : false


-----
이스케이프 문자 : 특수한 기능을 수행해주는 문자, \로 시작해야만 한다.
형식 : \이스케이프명
조건)
- 반드시 문자열 안에 기술해야 한다.

\t : 탭 1개 기능 수행
\n : (엔터 1개 기능 수행) 줄바꿈
\' : '
\" : " 
\\ : \

System.out.println("""); => " 출력하고 싶었으나 큰 따옴표 열고닫은 것으로 인식해서 오류 발생함. 필요 시 \" 라고 작성.

------
서식지정자 : 정해진 형식대로 넣어야하는 곳에 %로 시작하는 명령어
조건)
- 반드시 문자열 안에 기술해야 한다.
- 반드시 System.out.printf("문자열..."); // printf(); 메소드 호출문 안에만 사용 가능하다.
- 서식지정자의 갯수와 순서, 자료형에 따라서 그 만큼의 대응되는 값이 존재해야 한다. -> 
ex) System.out.printf("%c %d", 'A', (int)'A'); -> 출력값은 A, 65

- 반드시 대응하는 값이 존재해야 하는 서식지정자
%c : char 자료형 값만 넣을 수 있습니다.
%f : 실수형 자료형 값만 넣을 수 있습니다.
%d : 정수형 자료형 값만 넣을 수 있습니다.
%s : 문자열(String) 자료형 값만 넣을 수 있습니다.

- 대응하는 값이 존재하지 않아도 되는 서식지정자
%n : 이스케이프의 \n과 동일(줄바꿈 기능)
%% : % 

------
상수 : 값이 한 번 들어오면 절대 변경할 수 없는 수(공간)
선언방식 : final 자료형 이름 = 값;  - 선언과 동시에 초기화까지 해야 한다.

명명규칙 
- 전부 영어 대문자로 작명해 사용.
- 여러 단어가 붙을 시 스네이크 기법으로 작성.



------ 
println(), printf(), print()

println() : 줄바꿈의 명령도 갖고있다, ,로 결합할 수 없다.
ex) println("MM" , "nn") (X) / println("MM" + "nn") (O)
print() : 줄바꿈의 명령을 갖고있지 않기때문에  이스케이프 문자 "\n"를 사용하지 않으면 콘솔창에 계속 한줄로 작성된다.





===========
선택구조형 프로그래밍
- 조건문 : 조건에 의해 처리하는 실행문의 흐름을 제어하는 명령문
	if문 / if~else문 / if ~ else if ~ else문

- if문 
if( 조건문(=조건식) ) {
실행할 코드 기술;
}

- if else문
if ( 조건문) {
실행할 코드 기술;
} else {
실행 코드;
}

- if else if else문
if ( 조건문 ) {
실행 코드;
} else if ( 조건문 ) {
실행 코드;
}  else {
실행코드;
}