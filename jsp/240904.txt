#쿼리문 
    * select문
    [형식]
    select 컬럼명 || *
    from 테이블명
    where 컬럼명 연산자 비교할값
    group by 컬럼명, 컬럼명
    having
    order by 컬럼명 [asc | desc]

    * insert문
    [형식]
    정식형식 : insert into 테이블명 (컬럼명, 컬럼명, ...) values (값, 값, ...);
    단축형식 : insert into 테이블명 values (값, 값, ...); // 단, 해당 테이블에 존재하는 컬럼의 갯수와 컬럼의 순서대로 전부 값을 기술하는 경우만 사용가능

    * update문
    [형식]
    update 테이블명 set 변경할 컬럼명 = 변경할 값, 변경할 컬럼명 = 변경할 값 where 컬럼명 연산자 비교할값;

    * delete문
    [형식]
    delete from 테이블명 where 컬럼명 연산자 비교할값;

#DBCP (DataBase Connection Pool)
    : 필요한 connection객체를 미리 만들어 보관해두었다가 connection객체를 요청하는 사용자가 있으면 해당 객체를 바로 전달해주는 역할을 하는 연결객체 컨테이너임. 연결객체를 생성하도록 실행하는 기능과 생성된 객체를 보관하는 기능을 가지고 있으나 연결객체를 생성하는 것은 JDBC를 이용한다.

    * 웹 프로젝트에서 DBCP 설정방법과 순서
    1. src/main/webapp/META-INF 폴더 안에 context.xml 파일 생성
    [context.xml 파일 기술형식] :
        <Context>
            <Recource name="jdbc/설정한이름" // 이름을 설정할 때는 꼭 jdbc/로 시작하는 것이 권장.
            auth="Container"
            type="javax.sql.DataSource" // 내가 설정한 DBCP의 값을 갖고있음
            username="사용자계정명"
            password="설정한계정의비밀번호"
            driverClassName="oracle.jdbc.driver.OracleDriver"
            factory="org.apache.tomcat.dbcp.dbcp2.BasicDataSourceFactory" // connection객체를 담아두는 곳
            url="jdbc:oracle:thin:@localhost:1521:XE"
            maxTotal="200" // 미리 만들어두는 connection 객체의 양 설정 -> 미리 200개를 만들어둠
            maxIdle="100"/> // 대기 connection객체의 양 설정 -> maxTotal의 갯수가 넘어가도 maxIdle의 갯수까지는 오류 X
        </Context>

    2. DBCP를 이용하기 위해 java 코드로 기술해야하는 순서와 방법 
        - java.sql 패키지에서 필요한 클래스나 인터페이스들을 import
        - javax.sql 패키지에서 필요한 클래스나 인터페이스들을 import
        - javax.naming 패키지에서 필요한 클래스나 인터페이스들을 import
    
    3. Context 인터페이스 자료형을 통해 context.xml에 설정된 데이터를 가지고 온다.
        Context 컨텍스트객체명 = new InitialContext(); // Context는 인터페이스로 객체생성할 수 없음. 따라서 상속관계인 InitialContext 클래스로 생성
        DataSource 객체명 = (DataSource)컨텍스트객체명.lookup("java:comp/env/Context.xml 파일의 Recource 태그의 name 속성값"); // lookup() : 검색한다는 의미를 가진 메소드. Object 자료형으로 반환하기 때문에 DataSource 자료형으로 형 변환해야함.

    [예시]
    context.xml 파일의 내용 :
    <Recource name="jdbc/ServletProject" ~~~~/>
    Context ctx = new InitialContext();
    DataSource ds = (DataSource)ctx.lookup("java:comp/env/jdbc/ServletProject");
    Connection conn = ds.getConnection(); // Connection 객체 생성

#MVC 패턴(M:Model, V:View, C:Controller)
    * M(Model) : 데이터베이스에 관련된 일을 처리(백엔드) -> DTO(=VO), DAO, SERVICE 
        - DTO : 데이터베이스에 전달할 데이터를 저장하거나 전달하는 객체
        - DAO : 데이터베이스에 접근할 수 있는 SQL명령문 객체를 담고있는 객체
        - SERVICE : DAO에 바로 접근 전에 경유하는 객체로 아무런 기능없이 DAO에 일을 시키는 기능만 가지고 있는 객체

    * V(View) : 시용자가 보게 되는 페이지에 관련된 일을 처리(프론트엔드) -> .html, .jsp

    * C(Controller) : 요청과 응답 사이에서 필요한 기능이나 데이터들을 제어하는 역할 또는 처리하는 객체(백엔드) -> (=Servlet)

    [MVC 패턴]
        MVC1 패턴 : MVC 구분이 명확하지 않고 jsp소스코드에 한꺼번에 처리가 되어있는 패턴 // 서블릿이 없었을 때 사용했던 옛날 버전의 패턴임.
        MVC2 패턴 = MVC 패턴 : 서블릿이 존재하며 M, V, C의 구분이 명확하게 나뉘어 처리된 패턴

    * 서블릿 설정방법 : 
        - 어노테이션 방법
        
        - web.xml 파일에 servlet태그를 사용하여 설정하는 방법
        [예시]
            <!-- servlet 객체 생성 -->
            <servlet>
                <servlet-name>객체명</servlet-name>
                <filter-class>패키지명.서블릿클래스명</filter-class>
            </servlet>
            <!-- servlet 객체 실행할 조건 설정 -->
            <servlet-mapping>
                <servlet-name>객체명</servlet-name>
                <url-pattern>url경로</url-pattern>
            </servlet-mapping>

    * 서블릿 클래스 사용조건 :
        1. 반드시 HttpServlet 클래스를 상속받아서 구현해야 한다.
        2. 반드시 doGet, doPost 메소드를 오버라이드 해줘야 한다.

    * 서블릿과 필터의 차이점 : 
        필터 :  request, response 객체의 변경이나 추가 기능들을 처리하고 통과하는 기능만 제공. 애플리케이션이 실행이 되는 순간(웹 서버가 실행되는 순간)에 바로 객체 생성되어 준비. 요청에서 가장 먼저 처리되고 가장 마지막에 처리되는 객체

        서블릿 : 요청과 응답을 제어하는 객체. 필터를 제외한 요청을 가장 먼저 받아들이고, 응답에 대한 전반적인 일들을 처리하는 객체(필요한 서비스객체, 핸들러맵퍼객체, 응답url완성 등의 기능을 처리). 맨처음 한 번이라도 url패턴에 맞는 요청이 들어와야 그때 생성되어 사용됨.
    