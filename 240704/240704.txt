https://master-shin.tistory.com/8

오라클 DB XE
오라클 SQL Developer 23.1.1
설치전에 자바가 설치되어있어야함. -> *자바 환경변수 설정 필수*

- 오라클DB 
설치경로 변경 X - DB 비밀번호 설정 
외부에서 접근할 때 포트번호는 설치 시 Port for 'Oracle DataBase Listener' : 1521 확인 -> 포트번호 1521
인터넷으로 접근할 때 포트번호는 설치 시 Port for 'Oracle HTTP Listener' : 8080 확인 -> 포트번호 8080 
설치 후 내 PC - 속성 - 고급 시스템 설정 - 환경변수 - 시스템변수 내 Path 확인 - 오라클 경로 확인 or 
cmd창 - sqlplus "/as sysdba" 혹은 sqlplus / as sysdba -> 디렉토리 경로 대신 SQL 출력되면 정상
--------------------------------------------------------

# 데이터베이스
데이터베이스 : 데이터를 저장, 조작(변경), 삭제하기 쉬운 저장소를 의미함
데이터베이스 관리시스템(DBMS = DataBase Management System) : 데이터의 전반적인 부분을 관리하는 시스템을 말함

- 데이터베이스 종류
	RDBMS(Relational DataBase Management System) : 구조화된, 정형화된 (= 관계형의) 데이터베이스 관리 시스템 : 표(=테이블) 구조로 되어있는 데이터베이스 시스템을 의미하며 데이터는 각각의 표 구조로 저장되며 서로간의 관계를 통해 데이터를 관리할 수 있다. => Oracle(오라클), MySQL, MariaDB, MS SQL, PostgreSQL
=> 정형화된 구조 (=SQL : Structure Query Language) : 명령어 형식이 존재하는 언어

- RDBMS의 장점
1. 데이터를 관리하기가 쉽다.
2. 정형화된 SQL문을 사용하기 때문에 다른 DB간의 명령어 호환이 용이하다.
3. 데이터의 중복을 막을 수(= 처리할 수) 있다.
- RDBMS의 단점
1. 데이터를 다루는 것이 무겁다.
2. 대량의 데이터를 저장하거나 가져오는게 시간 소요가 많다.

	NoSQL(= Not Only SQL) : 명령어가 정형화된 것이 없는 데이터베이스 관리 시스템. => MongoDB, Cassandra, Amazon DynamoDB, Redis

- NoSQL의 장점
1. 대량의 데이터를 다루기가 쉽다.
2. JSON(=JavaScript Object Notationn) 형태로 데이터가 저장이 된다.
3. 거의 모든 프로그래밍 언어나 프레임워크에 호환성이 높다.

- NoSQL의 단점
1. 데이터의 유기적인 관계를 처리하기가 어렵다.
2. 데이터의 중복을 처리하기가 어렵다.

# SQL 
SQL : 구조화된 명령문을 가진 언어

DML(Data Manupulation Language) : 데이터를 조작(= 삽입, 변경, 삭제) 할 수 있는 언어 (데이터를 직접 다룸) : insert문, update문, delete문
파생 => DQL (Data Query Language) : 데이터를 변경하지 않으면서 조회만 해오는 언어 (데이터를 직접 다룸) : select

DDL(Data Defination Language) : 데이터를 정의(생성, 제거, 수정) 하는 언어 (데이터 이상급을 다룸) : create, drop, alter
DCL(Data Control Language) : 데이터를(= 권한부여, 권한회수) 제어하는 언어 (데이터 이상급을 다룸) : GRANT, REVOKE
파생 => TCL (Transaction Control Language) : DML에 대한 작업을 전부 완료시키는 작업(확정 = COMMIT), DML에 대한 작업을 전부 되돌리는 작업(ROLLBACK), DML에 대한 작업을 원하는 지점까지만 되돌리는 작업(=SAVEPOINT, CHECKPOINT)

# CLI & GUI
CLI (Command Line Interface) : 한 줄 명령문으로 제어할 수 있는 매개체가 되는 시스템(= 명령어 기반의 인터페이스)

GUI (Graphic User Interface) : 아이콘을 클릭하여 제어할 수 있는 매개체가 되는 시스템(= 아이콘 기반의 인터페이스)

# 오라클 SQL 명령문 : 반드시 세미콜론이 필요함
[사전준비사항]
	1. C:\oraclexe\app\oracle\product\11.2.0\server\rdbms\admin 폴더 안의 scott.sql 파일을 복사해서 다운로드 폴더에 붙여넣기
	2. 명령프롬프트 창 실행하여 다운로드 폴더로 작업디렉토리 변환하기
	 -> cd C:\Users\사용자계정폴더명\Downloads
	3. sqlplus 접속 -> sqlplus / as sysdba
	4. @scott.sql 실행하기 -> scott 계정과 scott 계정안에 테이블 생성됨


1. sqlplus에 접속 : (세미콜론 없음)
- 명령프롬프트창 -> sqlplus / as sysdba
- sqlplus "/as sysdba"
- splplus 사용자계정명/비밀번호@SID명 (예: TEST/1111@XE)
- sqlplus 사용자계정명/비밀번호 (*SID가 한 개인 데이터베이스인 경우)

2. 사용자 계정 생성하기 : (반드시 세미콜론 있어야함)
- CREATE USER 사용자계정명 IDENTIFIED BY 비밀번호;

3. 사용자 계정에 권한 부여하기
- GRANT 부여할권한명1, 부여할권한명2, ...  TO 사용자계정명;
예) GRANT CONNECT, RESOURCE, DBA TO TEST;

4. 원하는 계정으로 접속하기 또는 접속계정 전환하기 : (세미콜론 없음)
- CONNECT 사용자계정명/비밀번호
- CONN 사용자계정명/비밀번호 (예 : CONN TEST/1111)
(단 sysdba로 전환할 경우는 예외 : CONN / as sysdba)

5. 해당 계정에 생성된 테이블 목록 모두 확인하기
- SELECT * FROM TAB;

6. scott 계정에 있는 EMP, DEPT 테이블을 test 계정에 가져와서 생성하는 방법
- CREATE TABLE EMP AS SELECT * FROM SCOTT.EMP; // SCOTT 계정 EMP 테이블에 접근해 모든 것을 선택해 EMP 테이블 생성
- CREATE TABLE DEPT AS SELECT * FROM SCOTT.DEPT; // SCOTT 계정 DEPT 테이블에 접근해 모든 것을 선택해 DEPT 테이블 생성



privilege : 권한이 부여되지 않아 접근할 수 없다.
사용자 전환 실패 시 기존 사용자로 돌아가는 것이 아닌 아무 사용자도 갖고 있지 않는다.


# SELECT문 
[형식]
	SELECT절 => *(전체 컬럼) | 컬럼명1, 컬럼명2, ...
	FROM절 => [계정명.]테이블이름 // 내 계정의 테이블을 가져오는 경우 계정명 생략가능
	WHERE절 => 조건을 기술하는 자리
	GROUP BY절 => 가져올 데이터를 그룹화하는 조건에 해당되는 컬럼을 기술하는 자리
	HAVING절 => GROUP BY절에 해당되는 조건을 기술하는 자리 또는 그룹함수 조건을 기술하는 자리
	ORDER BY절 => 출력하는 데이터의 오름차순, 내림차순을 정의하는 자리

	SELECT 컬럼
	FROM 테이블
	WHERE 행조절조건
	ORDER BY 컬럼정렬;

기술순서 : SELECT FROM [WHERE GRUOP BY HAVING ORDER BY] // [ ] 는 생략가능
해석순서 : FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY

EX) 학급 테이블 내 번호 2 전우치 남자 25를 갖고오는 방법
SELCET 번호,이름 (컬럼 수를 조정하는 자리)
FROM 학급 (테이블을 지정하는 자리)
WHERE 번호 = 2 혹은 이름 = '전우치' // DB는 작은따옴표 사용 (행 수를 조정하는 자리)
ORDER BY 
-> SELECT * FROM 학급 WHERE 이름 = '전우치';

- 사원정보 테이블에서 부서번호가 30인 사람의 사번, 사원명, 직책, 부서번호를 가져오는 코드
SELECT EMPNO, ENAME, JOB, DEPTNO
FROM EMP
WHERE DEPTNO = '30';

-사원정보 테이블에서 사원명과 연봉, 입사일자를 가져오세요
SELECT ENAME, SAL, HIREDATE // 컬럼 칸수도 조정할 수 있음
FROM EMP;

- 부서번호가 10번인 부서의 부서명을 가져오세요
SELECT DNAME
FROM DEPT
WHERE DEPTNO = '10';

- 부서번호가 20번인 사원의 정보를 이름이 내림차순 되도록 출력하시오.
SELECT * 
FROM EMP
WHERE DEPTNO = '20'
ORDER BY ENAME DESC;

- 연봉이 2500 이상인 사원을 출력하시오.
SELECT *
FROM EMP
WHERE SAL >= 2500;

- 부서번호가 10번이고 직책이 사원인 사람의 사원번호, 사원명, 직책, 부서번호를 출력하시오.
SELECT EMPNO, ENAME, JOB, DEPTNO
FROM EMP
WHERE DEPTNO = 10 AND JOB = 'CLERK';

- 입사일자가 1982년 1월 1일 이후 입사한 사원이거나 직책이 관리자인 사원의 이름, 입사일자, 직책, 사번을 조회하는데, 가장 먼저 입사한 사원부터 늦게 입사한 사원 순서대로 출력하세요.
SELECT ENAME, HIREDATE, JOB, EMPNO
FROM EMP
WHERE HIREDATE >= '82-01-01' OR JOB ='MANAGER' // 이후 : 82-01-01~ 82-01-02... 처럼 기준이 더 작기 때문에 >= 사용
ORDER BY HIREDATE;

- 커미션이 300이거나 500이거나 1400인 사원의 이름, 입사일자, 커미션을 출력하세요
SELECT ENAME, HIREDATE, COMM
FROM EMP
WHERE COMM = 300 OR COMM = 500 OR COMM = 1400; // 숫자일 때 '' 쓰지않음.
// WHERE COMM IN (300,500,1400); // IN 연산자를 통해 코드 줄일 수 있음.

- 입사일자가 1981/5/1이후부터 1981/11/30 이전에 입사한 사원의 사번, 이름, 부서번호, 입사일자를 조회해오는데, 사번을 내림차순으로 가져오세요
SELECT EMPNO, ENAME, DEPTNO, HIREDATE
FROM EMP
WHERE HIREDATE BETWEEN '1981-05-01' AND '1981-11-30'
// WHERE HIREDATE >= '1981-05-01' AND HIREDATE <= '1981-11-30'
ORDER BY EMPNO DESC;

- 커미션이 300, 500, 1400이 아닌 사원의 사번, 이름, 커미션의 정보를 출력하세요.
SELECT EMPNO, ENAME, COMM
FROM EMP
WHERE COMM NOT IN(300, 500, 1400) OR COMM IS NULL;
WHERE NOT COMM IN(300, 500, 1400) OR COMM IS NULL;// NOT의 위치는 컬럼명 앞 뒤 상관없이 사용가능

[특징]
ORDER BY 컬럼명 [ASC] : 오름차순 // 기본값이 오름차순이기 때문에 생략가능
ORDER BY 컬럼명 DESC : 내림차순 // 기본값이 아니기 때문에 생략불가

SELECT * FROM EMP WHERE DEPTNO = '20'; (O) // 권장사항
SELECT * FROM EMP WHERE '20' = DEPTNO; (O) // 권장사항은 아니지만 이렇게 기술해도 출력은 된다.

#WHERE절 (조건절)
// 오라클에서 빈 문자열값과 NULL의 값은 동일하지 않다.
// UPDATE절을 제외한 '=' 는 모두 같다의 의미를 가진다.
// 오라클에서 !false 같은 값 앞에 ! 사용 불가. 같은 의미를 가진 NOT 사용

- 우선순위 연산자 : ( )
- 비교 연산자 <, >, <=, >= / 같다 : = / 다르다 : <>, !=, ^=
- 논리 연산자 NOT, AND, OR
- SQL 연산자 BETWEEN 값조건1 AND 값조건2, IN(값,값,값...), LIKE, IS NULL, IS NOT NULL

[형식]
컬럼명 BETWEEN 100 AND 200 : 100 이상 200 이하를 의미. 100보다 크거나 같고 200보다 작거나 같은
컬럼명 IN(값1,값2,값3,...) : 값1 이거나 값2 이거나 값3인 을 의미.
컬럼명 IS NULL : 컬럼의 값이 NULL인
컬럼명 IS NOT NULL : 컬럼의 값이 NULL이 아닌
컬럼명 LIKE '문자열값조건지정' : 문자열의 부분일치
	- 문자열값조건지정
	'%S' : 앞에 0글자 이상의 어떠한 글씨가 와도되지만, 반드시 대문자 'S'로 끝나는 값을 가진 데이터라는 의미
	예: 컬럼명 LIKE '%S'; --> 해당 컬럼에 대문자 'S'로 끝나는 값을 가진 데이터를 출력한다.

	'S%' : 반드시 앞에 첫 글자가 S로 시작하는 값을 가진 데이터
	예 : 컬럼명 LIKE 'S%'; --> 해당 컬럼에 대문자 'S'로 시작하는 값을 가진 데이터를 출력

	'%S%' : 대문자 'S'라는 글자가 포함된 값을 가진 데이터
	예 : 컬럼명 LIKE '%S%'; --> 해당 컬럼에 대문자 'S'를 포함하고 있는 값을 가진 데이터 출력

	'_S%' : 반드시 두번째 글자가 S로 시작되는 값을 가진 데이터
	'___S%' : 반드시 네번째 글자가 S로 시작되는 값을 가진 데이터 ===> _가 1칸을 의미함

	'%S_' : 끝에서 두번째 글자가 S로 끝나는 값을 가진 데이터 

[예제]
1. 이름이 J로 시작하는 사원의 이름, 사번, 입사일자를 출력하세요.
SELECT ENAME, EMPNO, HIREDATE
FROM EMP
WHERE ENAME LIKE 'J%';

2. 이름이 N으로 끝나는 사원의 이름, 사번, 연봉을 출력하고, 이름을 오름차순으로 출력하세요.
SELECT ENAME, EMPNO, HIREDATE
FROM EMP
WHERE ENAME LIKE '%N'
ORDER BY ENAME;

3. 이름에 A가 들어가는 사원의 정보를 출력하되, 입사일자가 내림차순이 되도록 출력하세요.
SELECT *
FROM EMP
WHERE ENAME LIKE '%A%'
ORDER BY HIREDATE DESC;

4. 이름의 두번째 글자가 A로 시작되는 사원의 정보를 모두 출력하세요.
SELECT *
FROM EMP
WHERE ENAME LIKE '_A%';

5. 이름의 두번째 글자가 L, 네번째 글자가 R로 시작하는 사원의 이름,사번,상위관리자 사번을 출력하세요.
SELECT ENAME, EMPNO, MGR
FROM EMP
WHERE ENAME LIKE '_L_R%';

6. 이름이 4글자이면서 D로 끝나는 사원을 출력하세요.
SELECT *
FROM EMP
WHERE ENAME LIKE '___D';
// WHERE ENAME LIKE '____' AND ENAME LIKE '%D';

7. 이름에 A글자가 포함되지 않은 사원의 사번, 이름을 출력하세요.
SELECT EMPNO, ENAME
FROM EMP
WHERE ENAME NOT LIKE '%A%';
// WHERE NOT ENAME LIKE '%A%';


----------------------------------------
#컬럼 별칭
: 컬럼명의 원본은 훼손하지 않지만, 출력할 때 보기 편하기 위해 컬럼명을 임시로 변경

[형식] 
SELECT 컬럼명 [AS] 별칭명 / SELECT 컬럼명 [AS] "별칭명"

- 별칭명에 ""(큰 따옴표)를 붙여야하는 조건
	1. 별칭에 공백이 들어있을 때
	2. 별칭에 특수문자가 포함될 때
	3. 별칭의 대소문자를 구분하고싶을 때


#문자열 결합연산자 || : SELECT절에서 사용 시 컬럼에 문자열도 결합해 출력할 수 있다.
예) SELECT ENAME || '의 총 급여는 ' || (SAL + COMM) || '입니다.'
[출력결과] 컬럼명 : 사원명의 총 급여는 (연봉 컬럼과 커미션 컬럼을 더한 값)입니다.
------
[예제]
1. 사원테이블에서 직책의 종류를 가져오기
SELECT DISTINCT JOB FROM EMP;

2. JONES의 부하직원 출력
SELECT * FROM EMP WHERE MGR = 7566;

3. BLAKE가 관리하는 부하직원을 검색한 뒤 해당 부하직원들의 직책은 어떤 것이 있는지 가져오기
SELECT DISTINCT JOB FROM EMP WHERE MGR = 7698;